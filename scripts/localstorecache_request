#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
#set -x

((EUID)) && exec sudo -- "$0" "$@"
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; if [[ -n "${tempDirectoryName:?}" ]]; then if [[ -d "${tempDirectoryName:?}" ]]; then rm -r "${tempDirectoryName:?}"; fi; fi' ERR

sregDir=""
if [[ "$1" == "--sreg-dir" ]]; then
    shift
    sregDir="$1"
    shift
fi
sregDir="$(sregi_find_dir --sreg-dir "$sregDir")"

crystalWorkdir="$(crystallize-getconf WorkDirectory)"
dbDir="$1"
crystalIdentifier="$2"
if [[ -z "$crystalIdentifier" ]]; then
    echo "Please specify a directory and a crystal identifier."
    exit 1
fi
hashFull="$(sha512sum <<< "$crystalIdentifier" | awk '{print $1;}')"
hashA="${hashFull:0:1}"
hashB="${hashFull:1:1}"
hashC="${hashFull:2:1}"
hashSubdir="$hashA/$hashB/$hashC"

# Clean up if there's an error to avoid leaving a broken cache entry
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; rm -rf "${dbLinkPath:?}" "$(readlink -e "$dbLinkPath")"' ERR

if [[ "$RANDOM" -lt 500 ]]; then
    scache_gc "$dbDir" "localstore"
fi

hashDir="$dbDir/$hashSubdir"
mkdir -p "$hashDir"
dbLinkPath="$hashDir/$hashFull"

finish() {
    rm -f "${dbLinkPath:?}.locked"
}
trap finish EXIT

if [[ -e "$dbLinkPath.locked" ]]; then
    warn "This LocalStore cache entry is already in use. If the process using it has crashed, remove $dbLinkPath.locked manually."
    warn "Waiting 30 minutes for process using it to finish..."

    waitForLockTries=0
    until [[ "$waitForLockTries" -ge 360 ]]; do
        if [[ -e "$dbLinkPath.locked" ]]; then
            warn "Still waiting, $((waitForLockTries - 360)) tries remaining... If the process using this LocalStore cache entry has crashed, remove $dbLinkPath.locked manually."
        else
            break
        fi
        waitForLockTries=$((waitForLockTries+1))
        sleep 5
    done

    if [[ -e "$dbLinkPath.locked" ]]; then
        die "This LocalStore cache entry has been in use for 30 minutes so giving up. If the process using it has crashed, remove $dbLinkPath.locked manually."
    fi
fi

trap - ERR
oldFilePath="$(readlink "$dbLinkPath")"
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; rm -rf "${dbLinkPath:?}" "$(readlink -e "$dbLinkPath")"' ERR

localStoreMatchArray=("$oldFilePath"/sreg_flush_localstore-*.LocalStore)
if ( ! [[ -e "${localStoreMatchArray[0]}" ]] ) || [[ -z "${localStoreMatchArray[0]}" ]]; then
    localStoreMatchArray=("$oldFilePath"/scache-*.LocalStore)
    cacheEntryFile="${localStoreMatchArray[0]}"
else
    cacheEntryFile="${localStoreMatchArray[0]}/LocalStore"
fi

if [[ ! -h "$dbLinkPath" ]] || [[ ! -d "$oldFilePath" ]] || [[ ! -d "$cacheEntryFile" ]] || [[ -z "$cacheEntryFile" ]]; then
    # Item is not in the cache, so add it

    # Lock the cache entry while we're editing it
    touch "$dbLinkPath.locked"

    # Make sure there isn't a dangling LocalStore content folder with no associated link
    find "$dbDir/ByCount" -maxdepth 2 -type d -name "$hashFull" -exec rm -rf {} \;
    if ! [[ -f "$dbLinkPath" ]]; then
        # Never seen this item before, so set the requestCount
        requestCount=1
    else
        requestCount="$(<"$dbLinkPath")"
        rm "$dbLinkPath"
    fi
    if [[ -z "$requestCount" ]]; then
        requestCount=1
    fi
    dbFileDir="$dbDir/ByCount/${requestCount:?}/$hashSubdir"
    dbFilePath="$dbFileDir/$hashFull"
    rm -rf "${dbFilePath:?}"
    mkdir -p "$dbFilePath"
    tempDirectoryName="$crystalWorkdir/localstorecache-request-$(date-uuid)"
    mkdir -p "$tempDirectoryName"
    (
        cd "$tempDirectoryName" || exit 1
        decrystallize --passphrase "$(sregi_get_passphrase "$sregDir")" "$crystalIdentifier" --here &> /dev/null
        mv ./* "$dbFilePath"
    )
    if [[ -e "$dbLinkPath" ]] || [[ -h "$dbLinkPath" ]]; then
        rm "$dbLinkPath"
    fi
    ln -s "$dbFilePath" "$dbLinkPath"

    # Done editing the cache entry, so release the lock
    rm "$dbLinkPath.locked"
fi
dbFilePath="$(readlink -e "$dbLinkPath")"
# First, make sure the link is good and fix it up if it's not.
if ! [[ -d "$dbFilePath" ]]; then
    find "$dbDir/ByCount" -mindepth 5 -maxdepth 5 -type d -name "$hashFull" -exec ln -sf {} "$dbLinkPath" \;
    dbFilePath="$(readlink -e "$dbLinkPath")"
fi
if ! [[ -d "$dbFilePath" ]]; then
    die "Could not find the cache file, despite there being a link to it!"
fi
dbFileOldPath="$dbFilePath"
dbFileDir="$(dirname "$dbFilePath")"
# Get the requestCount. There are three path components after it. I suspect there's a better way to do this.
oldCount="$(basename "$(dirname "$(dirname "$(dirname "$dbFileDir")")")")"
if ! [[ "$oldCount" =~ ^-?[0-9]+$ ]]; then
    rm "$dbLinkPath"
    oldCount="1"
fi
# Increment the item's requestCount.
requestCount=$(( oldCount + 1 ))
if [[ -z "$requestCount" ]]; then
    requestCount=1
fi
# First, get the names of where the file should go.
dbFileDir="$dbDir/ByCount/${requestCount:?}/$hashSubdir"
dbFilePath="$dbFileDir/$hashFull"
mkdir -p "$dbFileDir"
rm -rf "${dbFilePath:?}"
mv "$dbFileOldPath" "$dbFilePath"
rm "$dbLinkPath"
ln -s "$dbFilePath" "$dbLinkPath"

# Return the data to the caller
echo "$dbLinkPath"

# Clean up empty directories
if [[ "$RANDOM" -lt 500 ]]; then
    find "$dbDir" -type d -not -name "ByCount" -empty -delete
fi
if [[ -d "$tempDirectoryName" ]]; then
    rm -r "${tempDirectoryName:?}"
fi
