#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
#set -x

((EUID)) && exec sudo -- "$0" "$@"
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

useCustomPassphrase="$1"
shift
crystallizePassphrase="$1" # Custom passphrase only. Empty at this point if using configured passphrase
shift
logfile="$1"
shift

crystallize --version 2>&1 | tee -a "$logfile"

echo "The crystal will have the following address when it is ready: $CrystalID" >> "$logfile" # not using tee because it's already been printed to the user by the crystallize script

{
    echo "Time (log stage 1) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    crystalWorkdir="$(crystallize-getconf WorkDirectory)"
    export crystalWorkdir

    echo "Time (log stage 1) from http://timeapi.org/: "

    trap - ERR
    wget --delete-after --warc-file="$crystalWorkdir/$CrystalID.time-start" -e robots=off "http://www.timeapi.org/utc/now?\\Y-\\m-\\d-\\H-\\M-\\S-\\6N-\\z"
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    echo "Time (log stage 1b) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    echo "Working in $crystalWorkdir".

    echo "Arguments: " "$@"

    echo "Configuration: "

    cat /usr/local/etc/crystallize.conf

    crystalTitle="$(crystallize-getconf InstallationIdentifier)"
    export crystalTitle
    crystalCollection="$(crystallize-getconf Collection)"
    export crystalCollection
    [[ "$useCustomPassphrase" != "true" ]] && crystallizePassphrase="$(crystallize-getconf Passphrase)"
    export crystallizePassphrase

    export CrystalID="$1"

    echo "Environment: "

    uname -ap

    echo "Environment variables: "

    printenv

    echo "Network environment: "

    echo "IP address from DNS: "

    retryUntilSuccess 100 30 5 5 dig +short myip.opendns.com @resolver1.opendns.com

    echo "IP address from http://icanhazip.com/: "

    trap - ERR
    wget --delete-after --warc-file="$crystalWorkdir/$CrystalID.ip" -e robots=off http://icanhazip.com/ &
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    echo "Time (log stage 2) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    echo "Time (log stage 2) from http://timeapi.org/: "

    trap - ERR
    wget --delete-after --warc-file="$crystalWorkdir/$CrystalID.time-env" -e robots=off "http://www.timeapi.org/utc/now?\\Y-\\m-\\d-\\H-\\M-\\S-\\6N-\\z" &
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    echo "Time (log stage 2b) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    echo "20170928201310973799400_2d303430300a70ed51ebe5a8492cb3f6b5e043becae2"
    cat "$(which ember_bash_setup)"
    echo "20170928201310973799400_2d303430300a70ed51ebe5a8492cb3f6b5e043becae2"

    printf "%s" "$crystallizePassphrase" > "$crystalWorkdir/$CrystalID".tmp

    CrystallizeFirstArg="$1"
    shift

    #Resolve relative paths in the arguments, since GNU tar's -P doesn't
    CrystallizePaths=( "$@" )
    echo "First entry in array: ${CrystallizePaths[0]}"
    for i in "${!CrystallizePaths[@]}"; do
        #resolve path
        echo "Trying to resolve ${CrystallizePaths[$i]}..."
        setVariableToCommandOutput "abspath" "emreadlink" "${CrystallizePaths[$i]}"
        [[ -h "${abspath:?}" ]] || [[ -e "${abspath:?}" ]] || die "The file ${abspath:?} requested to be crystallized does not exist."
        CrystallizePaths[$i]="${abspath:?}"
    done

} &>> "$logfile"

echo "Creating checksum file..." 2>&1 | tee -a "$logfile"
{
    csum "${CrystallizePaths[@]}" - > "$crystalWorkdir/$CrystalID.csum"
} 2>&1 | tee -a "$logfile"

{
    CrystallizePaths+=("$crystalWorkdir/$CrystalID.csum")
    echo "Building local index..."
} &>> "$logfile"

hashdeep -c md5,sha1,sha256,tiger,whirlpool -j0 -e -o fbsd "$crystalWorkdir/""${CrystallizeFirstArg:?}" "${CrystallizePaths[@]}" "$crystalWorkdir/$CrystalID" | tee "$crystalWorkdir/$CrystalID.local.idx" 2>&1 | tee -a "$logfile" &
localIndexPid="$!"

echo "Building deep index..."
hashdeep -c md5,sha1,sha256,tiger,whirlpool -j0 -e -o fbsd -r "$crystalWorkdir/""$CrystallizeFirstArg" "${CrystallizePaths[@]}" "$crystalWorkdir/$CrystalID" | tee "$crystalWorkdir/$CrystalID.deep.idx" 2>&1 | tee -a "$logfile"

{
    echo "Waiting for local index..."
    wait "$localIndexPid"

    echo "Counting size..."

    crystalFilesSize="$(disk-size-in-bytes "$crystalWorkdir/""$CrystallizeFirstArg" "${CrystallizePaths[@]}" "$crystalWorkdir/$CrystalID")"
} &>> "$logfile"

#get available memory
memlimit=-1
if hash free 2>/dev/null; then
    if free | grep -q buff/cache; then
        #free has one column for buffers and cache
        memlimit="$(free | grep Mem: | awk 'FNR == 1 {print ($4+$6)}')"
    else
        #free has separate columns for buffers and cache
        memlimit="$(free | grep Mem: | awk 'FNR == 1 {print ($4+$6+$7)}')"
    fi
    #Output is in kilobytes
    memlimit="$((memlimit * 1000))"
elif hash vm_stat 2>/dev/null; then
    #The system doesn't have the free command; try vm_stat
    #use sum of free+inactive from vm_stat
    freel="$(vm_stat | grep "Pages free:" | awk 'FNR == 1 {print ($3)}')"
    free="${freel::${#freel}-1}"
    inactivel="$(vm_stat | grep "Pages inactive:" | awk 'FNR == 1 {print ($3)}')"
    inactive="${inactivel::${#inactivel}-1}"
    memlimit="$((free + inactive))"
    #Output is in 4096-byte pages
    memlimit="$((memlimit * 4096))"
else
    warn "Could not determine how much memory is available." 2>&1 | tee -a "$logfile"
fi

memlimit="$((memlimit - 1073741824))"

{
    echo "cd \"$(pwd)\""
    echo "CrystalID=\"$CrystalID\""
    echo "crystalWorkdir=\"$crystalWorkdir\""
    echo "crystalTitle=\"$crystalTitle\""
    echo "crystallizeVersion=\"${crystallizeVersion:?}\""
    echo "crystalCollection=\"$crystalCollection\""

    echo "Filesize: $crystalFilesSize"
    # For the progress bar, the estimate should be scaled up a bit to account
    # for the overhead of tarring the files (the amount varies depending
    # on the size of the files â€” many small files have more overhead than
    # a few big files). So, multiply the filesize estimate by 1.2, since that
    # seems to be a fairly typical increase, although this isn't scientific.
    # Because bash doesn't support arethmetic with decimals, instead of
    # multiplying by 1.2 directly, I multiply by 12 and then divide by 10,
    # which I'm pretty sure is the same thing.
    crystalFilesSize=$(( crystalFilesSize * 12 ))
    crystalFilesSize=$(( crystalFilesSize / 10 ))
    echo "Filesize estimate: $crystalFilesSize"

    echo "Sending..."
} &>> "$logfile"

# Get API keys for the non-streaming upload method
# crystallizeAccessKey="$(grep access ~/.config/ia.ini | head -n 1 | awk '{ print $3 }')"
# crystallizeSecretKey="$(grep secret ~/.config/ia.ini | head -n 1 | awk '{ print $3 }')"
# FIXME: May continue even when hashdeep is missing
# pack files into stream | measure rate of stream's flow | compress the stream | encrypt the stream | send the input to a checksummer and to the output | send the stream to ia
# For debugging the curl command, can add tee >(cat > "$crystalWorkdir/$CrystalID.local-coal5") to the pipeline to get a local copy of the coal5
# For the streaming upload (broken atm), (also remove the TmpUploadFile and pipe directly) do: s3-streaming-upload s3.us.archive.org "$crystalCollection" "$CrystalID" "$CrystalID.coal5" "$crystalFilesSize" "$crystalTitle" "Crystal $CrystalID" "Uploaded using Crystallize $crystallizeVersion; 1EA21BD8-DB7E-11E5-9733-728C37852114; $crystalTitle; $CrystalID"
CrystalTmpUploadFile="$crystalWorkdir/$CrystalID.coal5"
export CrystalTmpUploadFile

# GNU tar requires backslashes to be escaped in file names
if [[ "$OSTYPE" != darwin* ]]; then
    tarCrystallizePaths=("${CrystallizePaths[@]//\\/\\\\}")
else
    tarCrystallizePaths=("${CrystallizePaths[@]}")
fi

set +o pipefail
{ tar -cv -P -S --format pax "$crystalWorkdir/""$CrystallizeFirstArg" "${tarCrystallizePaths[@]}" "$crystalWorkdir/$CrystalID" "$crystalWorkdir/$CrystalID.local.idx" "$crystalWorkdir/$CrystalID.deep.idx" "$crystalWorkdir/$CrystalID.tmp" "$crystalWorkdir/$CrystalID.tmp" "$crystalWorkdir/$CrystalID.time-start.warc.gz" "$crystalWorkdir/$CrystalID.ip.warc.gz" "$crystalWorkdir/$CrystalID.time-env.warc.gz" | pv -tparbIfei 0.1 -s "$crystalFilesSize" | checkedxz --request-wait-after - -k -C sha256 -T 0 --lzma2=preset=1 --memlimit-compress="$memlimit" | gpg --yes -c -v --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp - | tee >(hashdeep -c md5,sha1,sha256,tiger,whirlpool -j0 -o fbcpsde > "$crystalWorkdir/$CrystalID.checksums") > "$CrystalTmpUploadFile" 2>&1 | tee -a "$logfile"; } 2>&1
exitCodes=("${PIPESTATUS[@]}") # this pattern for copying an array doesn't "work for associative arrays, or for arrays with non-contiguous indices". (quotation from https://stackoverflow.com/questions/19417015/how-to-copy-an-array-in-bash)
exitcode="${exitCodes[0]}"
#Ignore exit code 1 from tar on Linux, which indicates files changed while reading; see http://stackoverflow.com/questions/20318852/tar-file-changed-as-we-read-it
if [[ "$exitcode" != "0" ]] && [[ $OSTYPE != *inux* ]]; then
    exit "$exitcode"
fi
if [[ "$exitcode" != "1" ]] && [[ "$exitcode" != "0" ]]; then
    exit "$exitcode"
fi
pipecheck "${exitCodes[@]:1}"
set -o pipefail

{
    echo "Please wait, pre-testing item before upload..."
    testDecrystDir="$(tempDir)"
    (
        cd "$testDecrystDir" || die "cd failed"
        tempId="unpack-test-$(date-uuid)"
        mkdir "$tempId"
        crystalXzFileSize="$(disk-size-in-bytes "$CrystalTmpUploadFile")"
        pv -tparbIfei 0.1 -s "$crystalXzFileSize" < "$CrystalTmpUploadFile" | gpg --yes --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp - | unxz --stdout - | tar -xvf - -C "$tempId/" || die "Could not extract the local packed crystal!"

        cp "$crystalWorkdir/$CrystalID.csum" "$tempId.csum"
        cd "$tempId" || die "cd failed"
        find . -name "$CrystalID"'*' -delete || die
        csum --check ./* "../$tempId.csum" || die
    )
    rm -r "${testDecrystDir:?}"
    echo "Please wait..."
} &>> "$logfile"

unset opt
unset optb

trap - ERR
#If GNU/Linux, set opt to 1 and unset optb; otherwise opposite
[[ "$OSTYPE" = *inux* ]] && (( opt++ ))
[[ "$OSTYPE" != *inux* ]] && (( optb++ ))
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

script ${optb+/dev/null} ${opt+-e} ${opt+-q} ${opt+-c} crystallize-internal-ia ${opt+/dev/null} 2>&1 | tee -a "$logfile" 1>&2

{
    #sendRetries=0
    #until [[ $sendRetries -ge 100 ]]; do
        #curl --location --raw -X PUT --data-binary @"$CrystalTmpUploadFile" --header "x-amz-auto-make-bucket:1" --header "x-archive-queue-derive:0" --header "x-archive-size-hint:$crystalFilesSize" --header "authorization: LOW $crystallizeAccessKey:$crystallizeSecretKey" --header "x-archive-meta-collection:$crystalCollection" --header "x-archive-meta-title:$CrystalID" --header "x-archive-meta-description:Crystal $CrystalID" --header "x-archive-meta-subject:Uploaded using Crystallize $crystallizeVersion; 1EA21BD8-DB7E-11E5-9733-728C37852114; $crystalTitle; $CrystalID" "http://s3.us.archive.org/$CrystalID/$CrystalID.coal5" && break
    #    sendRetries=$((sendRetries+1))
    #    sleep 30
    #done

    echo "Retrieving remote index..."

    retryUntilSuccess 100 30 5 5 wget --delete-after --save-headers --output-document - "https://archive.org/metadata/$CrystalID/" | tee "$crystalWorkdir/$CrystalID.json"

    #If the opt(b) variable is unset, insert the text after "opt(b)+"
    #opt is for GNU/Linux; optb is for others
    script ${optb+/dev/null} ${opt+-e} ${opt+-c} crystallize-internal-xz-b ${opt+/dev/null}

    echo "Copying indices..."

    cp "$crystalWorkdir/$CrystalID.tmp" "$crystalWorkdir/$CrystalID.passphrase"

    rsync -av --progress --checksum "$crystalWorkdir/$CrystalID.local.idx" "$crystalWorkdir/$CrystalID.deep.idx" "$crystalWorkdir/$CrystalID.checksums" "$crystalWorkdir/$CrystalID.json.xz" "$crystalWorkdir/$CrystalID.passphrase" "${EmberLibrary:?}"/Futuramerlin\ Projects/Data/Crystal\ Index/

    echo "rsynced..."

    #Clear the screen
    printf "\\033c"

    #Delete everything except log
    #echo "Cleaning up..."
    #yes | rm -rv "${CrystallizePaths[@]}"
    #echo "Done cleaning up..."

    echo "Time (log stage 3) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    echo "Time (log stage 3) from http://timeapi.org/: "

    trap - ERR
    wget --delete-after --warc-file="$crystalWorkdir/$CrystalID.time-done" -e robots=off "http://www.timeapi.org/utc/now?\\Y-\\m-\\d-\\H-\\M-\\S-\\6N-\\z"
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    echo "Time (log stage 3b) locally:"

    date +%Y-%m-%d-%H-%M-%S-%N
    xxd -pu <<< "$(date +%z)"

    #Clear the screen
    printf "\\033c"

    echo "Finishing $CrystalID..."

    echo "Please wait..."
} &>> "$logfile"
