#!/bin/bash

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# shellcheck disable=SC1091
source crystallize-bash_setup

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source futuramerlin-web-toolkit-s &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    exit 1
}
export -f die

function embasename() {
    (
        path="$1"
        if [[ "$path" == "/" ]]; then
            printf "/"
            exit 0
        elif [[ "$1" =~ '/'$ ]]; then
            path="${path::${#path}-1}"
        fi
        printf "%s" "${path##*/}"
    )
}
export -f embasename

function emreadlink() {
    (
        cd "$(dirname "$1")" || exit 1
        setVariableToCommandOutput "basename" "embasename" "$1"
        printf "%s/%s" "$PWD" "${basename:?}"
    )
}
export -f emreadlink

function setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        exit 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    eval "$save_traps"
}
export -f setVariableToCommandOutput

function ereplace() {
    ereplaceFrom="$1"
    ereplaceTo="$2"
    export ereplaceFrom
    export ereplaceTo
    ereplaceFromEsc="$(perl -0777 -e 'print(quotemeta($ENV{ereplaceFrom}))')"
    ereplaceToEsc="$(perl -0777 -e 'print(quotemeta($ENV{ereplaceTo}))')"
    unset ereplaceFrom
    unset ereplaceTo
    perl -0777 -p -i -e "s/$ereplaceFromEsc/$ereplaceToEsc/g" "$3"
}
export -f ereplace

function print() {
    printf "%s" "$1"
}
export -f print

function readconf() {
    key="$1"
    file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    declare -a readconfValue
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+="$line"
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+="$(cut -f2 -d, <<< "$line")"
                fi
            fi
        fi
    done < "$2"
    export readconfValue
}
export -f readconf

function preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}
export -f preadconf
