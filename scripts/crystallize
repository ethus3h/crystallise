#!/usr/bin/env bash

if [[ "$1" == "--version" ]]; then
    # shellcheck disable=SC2034
    echo "Crystallize version $(crystallize-getconf crystallizeVersion) using ember-shared version $(e8787d06e61943a6874e94985b53bc0a="2dee41bf-53fb-4f65-997f-33bf50bfbb4d"; ember_bash_setup --version)."
    exit 0
fi

# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
#set -x

export crystallizeVersion='3.1.2.5.10.68'

# The update script shown here requires there to be only one ebuild of crystallize in the wreathe-overlay overlay.
# ( sudo true; newVersion="3.1.2.5.10.68"; cd "/Ember Library/Ember satellite projects/crystallize"; eogup-single; git tag -a "v$newVersion" -m "version"; egup-single .; cd "/Ember Library/Ember satellite projects/wreathe-overlay"; eogup-single; mv app-misc/crystallize/crystallize-*.ebuild "app-misc/crystallize/crystallize-$newVersion.ebuild"; repoman manifest; egup-single; sudo layman -s wreathe-overlay; sudo emerge crystallize; sudo dispatch-conf )

((EUID)) && exec sudo -- "$0" "$@"

finishclean() {
    rm -f "${crystalWorkdir:?}/${CrystalID:?}.coal5"
}
trap 'cat "$crystalWorkdir/$CrystalID" || true; finishclean; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

if [[ ! -e "${EmberLibrary:?}"/Futuramerlin\ Projects/Data/Crystal\ Index/ ]]; then
    echo "ERROR: Could not find a usable Ember Library directory tree. Nothing done."
    exit 1
fi

if ! [[ -d . ]]; then
    echo "Please run crystallize from a directory that exists."
    exit 1
fi

keepFiles="false"
if [[ "$1" == "--keep" ]]; then
    keepFiles="true"
    shift
fi

useCustomPassphrase="false"
customPassphrase=""
if [[ "$1" == "--passphrase" ]]; then
    useCustomPassphrase="true"
    shift
    customPassphrase="$1"
    shift
fi

#Remove first argument if it's the end-of-options delimiter
if [[ "$1" == "--" ]]; then
    shift
fi

if [[ "$1" == "" ]] || [[ "$1" == "." ]] || [[ "$1" == ".." ]] || [[ "$1" == "./" ]] || [[ "$1" =~ ^../ ]]; then
    echo "Please specify file(s) within the current directory to crystallize when using relative path names."
    exit 1
fi

crystalWorkdir="$(crystallize-getconf WorkDirectory)"
export crystalWorkdir
mkdir -p "$crystalWorkdir"

#Check for and handle option to leave behind a pointer
if [[ "$1" == "--leave-pointer" ]]; then
    echo "Pointer is enabled."
    crystallizeLeavePointer=true
    shift
    if [[ "$#" -gt 1 ]]; then
        echo "Please use pointer option with only 1 item at a time."
        exit 1
    fi
    mkdir -p "$crystalWorkdir/pointers"
    #Only use first 136 characters of file name for directory name; hopefully this will prevent the name being too long for the filesystem
    crystallizeBaseName="$(basename "$1")"
    crystallizePointerDir="$crystalWorkdir/pointers/.${crystallizeBaseName:0:136}".crystal-data
    crystallizePointerName="$crystalWorkdir/pointers/${crystallizeBaseName:0:136}".crystal
    if [[ -e "$crystallizePointerDir" ]]; then
        crystallize "$crystallizePointerDir"
    fi
    if [[ -e "$crystallizePointerName" ]]; then
        crystallize "$crystallizePointerName"
    fi
    echo "Pointer directory: $crystallizePointerDir"
    echo "Pointer name: $crystallizePointerName"
fi

CrystalID="C3-$(date-uuid)"
export CrystalID

echo "The crystal will have the following address when it is ready: $CrystalID"$'\n'

# -t 1 checks if file descriptor 1 "is opened on a terminal" (â€”GNU coreutils 8.25 manpage for test)
if [[ -t 1 ]]; then
    warn-timeout "Be careful that you don't crystallize your current working directory, the crystallize temp dir, or the crystallize scripts themselves. Either could cause problems. (It's more likely to be OK if you use --keep, but still not guaranteed.)" &
fi

dig +short myip.opendns.com @resolver1.opendns.com > /dev/null || die "Could not connect to OpenDNS. Is UDP traffic being blocked by a firewall?"

wait

crystallize-logsession "$useCustomPassphrase" "$customPassphrase" "$crystalWorkdir/$CrystalID" "$CrystalID" "$@"

#echo "Working..."
echo "$0 $*" > "$crystalWorkdir/$CrystalID.cmd"
pwd > "$crystalWorkdir/$CrystalID.cwd"
#Script should not exit if an operation fails. FIXME: why?
if [[ $crystallizeLeavePointer == true ]]; then
    mkdir -p "$crystallizePointerDir"
    rsync -a --checksum "$crystalWorkdir/$CrystalID.local.idx" "$crystalWorkdir/$CrystalID.deep.idx" "$crystalWorkdir/$CrystalID.cmd" "$crystalWorkdir/$CrystalID.cwd" "$crystallizePointerDir"/
fi
trap - ERR
checkedxz "$crystalWorkdir/$CrystalID" -C sha256 -v -9 -e
checkedxz "$crystalWorkdir/$CrystalID.time-done.warc.gz" -C sha256 -v -9 -e
checkedxz "$crystalWorkdir/$CrystalID.local.idx" -C sha256 -v -9 -e
checkedxz "$crystalWorkdir/$CrystalID.deep.idx" -C sha256 -v -9 -e
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.xz"
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.time-done.warc.gz.xz"
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.local.idx.xz"
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.deep.idx.xz"
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.cmd"
gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "$crystalWorkdir/$CrystalID".tmp "$crystalWorkdir/$CrystalID.cwd"
rm "$crystalWorkdir/$CrystalID.tmp" "$crystalWorkdir/$CrystalID.local.idx.xz" "$crystalWorkdir/$CrystalID.deep.idx.xz" "$crystalWorkdir/$CrystalID.cmd" "$crystalWorkdir/$CrystalID.cwd" "$crystalWorkdir/$CrystalID.time-done.warc.gz.xz" "$crystalWorkdir/$CrystalID.time-env.warc.gz" "$crystalWorkdir/$CrystalID.time-start.warc.gz" "$crystalWorkdir/$CrystalID.xz" "$crystalWorkdir/$CrystalID.ip.warc.gz" "$crystalWorkdir/$CrystalID.passphrase"
mv "$crystalWorkdir/$CrystalID.xz.gpg" "$crystalWorkdir/$CrystalID.coal5-log"
mv "$crystalWorkdir/$CrystalID.time-done.warc.gz.xz.gpg" "$crystalWorkdir/$CrystalID.coal5-timestamp"
mv "$crystalWorkdir/$CrystalID.local.idx.xz.gpg" "$crystalWorkdir/$CrystalID.coal5-idx-l"
mv "$crystalWorkdir/$CrystalID.deep.idx.xz.gpg" "$crystalWorkdir/$CrystalID.coal5-idx-d"
mv "$crystalWorkdir/$CrystalID.cmd.gpg" "$crystalWorkdir/$CrystalID.coal5-cmd"
mv "$crystalWorkdir/$CrystalID.cwd.gpg" "$crystalWorkdir/$CrystalID.coal5-cwd"

trap 'cat "$crystalWorkdir/$CrystalID" || true; finishclean; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
ia upload "$CrystalID" --retries=100 --verify --delete "$crystalWorkdir/$CrystalID.coal5-log" "$crystalWorkdir/$CrystalID.coal5-idx-l" "$crystalWorkdir/$CrystalID.coal5-idx-d" "$crystalWorkdir/$CrystalID.coal5-cmd" "$crystalWorkdir/$CrystalID.coal5-cwd"
ia upload "$CrystalID" --retries=100 --verify "$crystalWorkdir/$CrystalID.coal5-timestamp"

echo "Please wait..."

# Check that things were correctly uploaded

sleep 2

postUploadCheckSuccess=""
postUploadCheckFailHandler() {
    if [[ -z "$postUploadCheckSuccess" ]] || [[ "$postUploadCheckSuccess" == "1" ]]; then
        postUploadCheckSuccess=1
    else
        postUploadCheckSuccess=0
    fi
}

getChecksumRetries=0
retryDelayTime=5
until [[ "$getChecksumRetries" -ge 1000 ]]; do
    if wget -qO - https://archive.org/download/"$CrystalID/$CrystalID"_files.xml | grep -F "<file name=\"$CrystalID.coal5\" source=\"original\">" > /dev/null; then
        postUploadCheckFailHandler
        break
    fi
    getChecksumRetries=$((getChecksumRetries+1))
    sleep "$retryDelayTime"
    if [[ "$retryDelayTime" -lt 30 ]]; then
        retryDelayTime=$((retryDelayTime + 5))
    fi
done

knownChecksum="$(grep ",stdin" "$crystalWorkdir/$CrystalID.checksums" | awk -F',' '{print $3}')"

getChecksumOuterRetries=0
getChecksumRetries=0
retryOuterDelayTime=5
retryDelayTime=5
until [[ "$getChecksumOuterRetries" -ge 15 ]]; do
    until [[ "$getChecksumRetries" -ge 100 ]]; do
        if checksumLine="$(wget -qO - https://archive.org/download/"$CrystalID/$CrystalID"_files.xml | grep -F -A 6 "<file name=\"$CrystalID.coal5\" source=\"original\">" | grep "<sha1>" | head -n 1)"; then
            postUploadCheckFailHandler
            break
        fi
        getChecksumRetries=$((getChecksumRetries+1))
        sleep "$retryDelayTime"
        if [[ "$retryDelayTime" -lt 30 ]]; then
            retryDelayTime=$((retryDelayTime + 5))
        fi
    done
    checksumLine="${checksumLine/    <sha1>/}"
    checksumLine="${checksumLine/<\/sha1>/}"
    if [[ "$checksumLine" == "$knownChecksum" ]]; then
        break
    else
        getChecksumOuterRetries=$((getChecksumOuterRetries+1))
    fi
    sleep "$retryOuterDelayTime"
    if [[ "$retryOuterDelayTime" -lt 30 ]]; then
        retryOuterDelayTime=$((retryOuterDelayTime + 5))
    fi
done

# First, check against the stored checksum
if [[ "$checksumLine" != "$knownChecksum" ]]; then
    die "ERROR! Checksum known by Internet Archive $checksumLine does not match saved checksum known locally $knownChecksum."
fi

# Now, check the local file's checksum again in case it's gotten screwed up in the mean time somehow
knownChecksum="$(hashdeep -c sha1 -j0 -o fbcpsde < "$crystalWorkdir/$CrystalID.coal5" | grep ",stdin" | awk -F',' '{print $2}')"
if [[ "$checksumLine" != "$knownChecksum" ]]; then
    die "ERROR! Checksum known by Internet Archive $checksumLine does not match new checksum known locally $knownChecksum."
fi

getChecksumRetries=0
retryDelayTime=5
until [[ $getChecksumRetries -ge 1000 ]]; do
    if wget -qO - https://archive.org/download/"$CrystalID/$CrystalID"_files.xml | grep -F "<file name=\"$CrystalID.coal5-timestamp\" source=\"original\">" > /dev/null; then
        postUploadCheckFailHandler
        break
    fi
    getChecksumRetries=$((getChecksumRetries+1))
    sleep $retryDelayTime
    if [[ $retryDelayTime -lt 30 ]]; then
        retryDelayTime=$((retryDelayTime + 5))
    fi
done

if [[ "$postUploadCheckSuccess" != "1" ]]; then
    die "ERROR! Post-upload check failed: data appear to not have been transferred successfully!"
fi

echo "Retrieving remote index..."

rm -f "$crystalWorkdir/$CrystalID".json.xz
wget --delete-after --save-headers --output-document - "https://archive.org/metadata/$CrystalID/" > "$crystalWorkdir/$CrystalID.json"
checkedxz "$crystalWorkdir/$CrystalID".json -C sha256 -9 -e -v

rsync -av --progress --checksum "$crystalWorkdir/$CrystalID.json.xz" "$crystalWorkdir/$CrystalID.checksums" "${EmberLibrary:?}"/Futuramerlin\ Projects/Data/Crystal\ Index/

rm "$crystalWorkdir/$CrystalID.json.xz" "$crystalWorkdir/$CrystalID.checksums"

# Next section registers the newly created crystal in the CrystalCache so an immediate decrystallize doesn't need to re-download it.

if ! [[ -e "$crystalWorkdir/.CrystalCache/" ]]; then
    fcache_init "$crystalWorkdir/.CrystalCache/" 5000000000
fi

dbDir="$crystalWorkdir/.CrystalCache/"
scache_gc "$dbDir" "f"

requestUrl="https://archive.org/download/$CrystalID/$CrystalID.coal5"
hashFull="$(sha512sum <<< "$requestUrl" | awk '{print $1;}')"
hashA="${hashFull:0:1}"
hashB="${hashFull:1:1}"
hashC="${hashFull:2:1}"
hashSubdir="$hashA/$hashB/$hashC"
hashDir="$dbDir/$hashSubdir"
mkdir -p "$hashDir"
dbLinkPath="$hashDir/$hashFull"
checksumName="$dbLinkPath.checksum"

finish() {
    rm -f "${dbLinkPath:?}.locked"
}
trap finish EXIT
# Don't remove .coal5 file if it fails after this point
trap 'cat "$crystalWorkdir/$CrystalID" || true; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

[[ -e "$dbLinkPath.locked" ]] && die "This URL cache entry (for a supposedly new crystal) is already in use. This should never happen, and indicates a bug in crystallize."

if [[ -e "$dbLinkPath" ]] || [[ -h "$dbLinkPath" ]]; then
    die "This URL cache entry (for a supposedly new crystal) already exists. This should never happen, and indicates a bug in crystallize."
fi

[[ -e "$checksumName" ]] && die "This URL cache entry (for a supposedly new crystal) already has a checksum file. This should never happen, and indicates a bug in crystallize."

echo "locked on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)" > "$dbLinkPath.locked"

requestCount=0
dbFileDir="$dbDir/ByCount/${requestCount:?}/$hashSubdir"
dbFilePath="$dbFileDir/$hashFull"
mkdir -p "$dbFileDir"
mv "$crystalWorkdir/$CrystalID.coal5" "$dbFilePath"
sha512sum < "$dbFilePath" | awk '{print $1;}' > "$checksumName"
printf "%s" "$requestUrl" > "$dbLinkPath.url"

ln -s "$dbFilePath" "$dbLinkPath"

# Done editing the cache entry, so release the lock
rm "$dbLinkPath.locked"

#Build this again for the rm command
CrystallizePaths=( "$@" )
for i in "${!CrystallizePaths[@]}"; do
    #resolve path
    #echo "Trying to resolve ${CrystallizePaths[$i]}..."
    setVariableToCommandOutput "abspath" "emreadlink" "${CrystallizePaths[$i]}"
    CrystallizePaths[$i]="${abspath:?}"
done

#Delete everything except log
#echo "Cleaning up..."
set +o pipefail
trap - ERR
if [[ "$keepFiles" != "true" ]]; then
    rm -rf "${CrystallizePaths[@]}"
fi
trap 'cat "$crystalWorkdir/$CrystalID" || true; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
set -o pipefail
echo "Done cleaning up..."

if [[ $crystallizeLeavePointer == true ]]; then
    echo "$CrystalID" > "$crystallizePointerDir"/identifier
    echo "$CrystalID" > "$crystallizePointerName"
    #echo "Added crystal ID"
    if [[ -e "$(basename "$crystallizePointerDir")" ]]; then
        crystallize "$(basename "$crystallizePointerDir")"
    fi
    if [[ -e "$(basename "$crystallizePointerName")" ]]; then
        crystallize "$(basename "$crystallizePointerName")"
    fi
    rsync -av --progress --checksum "$crystalWorkdir"/pointers/"$(basename "$crystallizePointerName")" "$crystalWorkdir"/pointers/"$(basename "$crystallizePointerDir")" .
    #echo "Pointer directory: $crystallizePointerDir"
    #echo "Pointer name: $crystallizePointerName"
fi

if rm -v "$crystalWorkdir/$CrystalID.coal5-timestamp"; then
    #Clear the screen
    printf "\\033c"

    echo "Done! The new crystal's address is:"
    echo "$CrystalID"
else
    #Clear the screen
    printf "\\033c"

    echo "Crystallisation failed! This is bad!"
    exit 1
fi
