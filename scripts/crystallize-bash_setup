#!/usr/bin/env bash
#set -x

rubberfs() {
    if [[ "$1" == "cd" ]]; then
        name="$2"
        if [[ ! -n "$name" ]]; then
            name="library"
        fi
        cd "/Wreathe/.Resources/RubberFS/$name/mount" || exit 1
    else
        "$(which rubberfs)" "$@"
    fi
}

git-absolute-path() {
    fullpath="$(readlink -f "$1")"
    gitroot="$(git rev-parse --show-toplevel)" || return 1
    [[ $fullpath == *$(printf %q "$gitroot")* ]] && echo "${fullpath/$gitroot\//}"
}

git-escape-path() {
    # (doesn't handle the case of the bash variable containing exactly one newline and that newline not being at the end)
    if [[ "$(wc -l <<< "$1")" == "1" ]] || [[ "$(wc -l <<< "$1")" == "0" ]]; then
        sed 's/./&\\/g' <<< "$1" | awk '{print "\\"$1}' | sed 's/.$//'
    else
        exit 1
    fi
}

sreg_fuse() {
    sreg_fuse.py "$@" "${EmberLibrary:?}/Futuramerlin Projects/Data/Stream Registry/"
}

# Function is defined with parentheses to make it run in a subshell to prevent the "die" affecting the calling script (the calling script should be responsible for trapping/handling nonzero exit codes itself)
sregi_available_by_hash() (
    knownChecksum="${knownChecksum:?}"
    hashA="${knownChecksum:0:1}"
    hashB="${knownChecksum:1:1}"
    hashC="${knownChecksum:2:1}"
    if [[ -n "$1" ]]; then
        local availByHashPointerFile="$1"
    else
        local availByHashPointerFile="${EmberLibrary:?}/Futuramerlin Projects/Data/Stream Registry/$hashA/$hashB/$hashC/$knownChecksum"
    fi
    if ! [[ -e "$availByHashPointerFile" ]]; then
        die "Item does not have the corresponding stream registry entry $availByHashPointerFile!"
    fi
    local innerPointerTypeSignature="$(head -c 36 "$availByHashPointerFile")"
    local dbDir="${EmberLibrary:?}"/Futuramerlin\ Projects/Data/Stream\ Registry
    if [[ "$innerPointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
        if ! [[ -f "$dbDir/LocalStore/$hashA/$hashB/$hashC/$knownChecksum" ]]; then
            die "Item does not have the corresponding LocalStore entry $dbDir/LocalStore/$hashA/$hashB/$hashC/$knownChecksum!"
        fi
    fi
)

sregi_hash_from_file() (
    # Function is defined with parentheses to make it run in a subshell to prevent the definition of pipecheck clobbering other functions named that in the calling script
    file="$1"
    pipecheck() {
        (
        pipeCheckTemp=("${PIPESTATUS[@]}")
        if [[ "${pipeCheckTemp[0]}" != "141" ]] && [[ "${pipeCheckTemp[0]}" != "0" ]]; then
            # Ignore status 141, which just means the input stream was terminated by head before all the data were consumed
            die "Failed reading temporary stream file"
        fi
        if [[ "${pipeCheckTemp[1]}" != "0" ]]; then
            die "Failed executing head on temporary stream file"
        fi
        )
    }
    set +o pipefail
    tail -c +38 "$file" | head -c 129
    pipecheck
    set -o pipefail
)

EmberLibrary="$(crystallize-getconf EmberLibrary)"
