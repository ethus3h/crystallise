#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
#set -x

((EUID)) && exec sudo -- "$0" "$@"

sregDir=""
if [[ "$1" == "--sreg-dir" ]]; then
    shift
    sregDir="$1"
    shift
fi
sregDir="$(sregi_find_dir --sreg-dir "$sregDir" --full-check)"

outFile=""
if [[ "$1" == "--output-file" ]]; then
    shift
    outFile="$1"
    shift
fi

finish() {
    (
        cd "/${crystalWorkdir:?}/" || die
        if [[ -e "${streamId:?}" ]]; then
            rm -r "${streamId:?}"
        fi
    )
}
trap 'error-notify "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; finish; exit 1' ERR

dbDir="$sregDir"
crystalWorkdir="$(crystallize-getconf WorkDirectory)"
# Don't rename this to sreg. I think this name is needed for reading it
streamId="scache-$(date-uuid)"
mkdir -p "$crystalWorkdir/$streamId"
(
    cd "$crystalWorkdir/$streamId" || die
    sponge "$streamId.tmp"
    # Calculate hash
    if [[ "$1" == "--assume-checksum" ]]; then
        shift
        hashFull="$1"
        shift
    else
        hashFull="$(sha512sum < "$streamId.tmp" | awk '{print $1;}')"
    fi
    inputPointerTypeSignature=""
    if ! [[ "$(wc -c < "$streamId.tmp")" -lt 166 ]]; then
        inputPointerTypeSignature="$(head -c 36 "$streamId.tmp")"
    fi
    if [[ "$inputPointerTypeSignature" == "a5e2f296-3085-49c0-8f48-24ea436b7a8b" ]] || # Standard remote pointer
        [[ "$inputPointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]] || # LocalStore pointer
        [[ "$inputPointerTypeSignature" == "2fae2004-94bb-4aa8-a01a-fc44298efc2c" ]] || # Remote pack pointer
        [[ "$inputPointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]] || # Remote pack pointer, with pointer data in the pointer
        [[ "$inputPointerTypeSignature" == "760fa662-89cf-4ebd-9664-150b7637ddd4" ]] # Hash pointer
    then
        die "The input stream is a sreg pointer, and cannot be safely stored."
    fi
    if [[ -n "$outFile" ]]; then
        if [[ -f "$outFile" ]]; then
            pointerTypeSignature=""
            if ! [[ "$(wc -c < "$outFile")" -lt 166 ]]; then
                pointerTypeSignature="$(head -c 36 "$outFile")"
            fi
            if [[ "$pointerTypeSignature" == "760fa662-89cf-4ebd-9664-150b7637ddd4" ]]; then
                # The file is a hash pointer. This is fine: continue nomally.
                true
            elif [[ "$pointerTypeSignature" == "a5e2f296-3085-49c0-8f48-24ea436b7a8b" ]] || # Standard remote pointer
                [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]] || # LocalStore pointer
                [[ "$pointerTypeSignature" == "2fae2004-94bb-4aa8-a01a-fc44298efc2c" ]] || # Remote pack pointer
                [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]] # Remote pack pointer, with pointer data in the pointer
            then
                # The file is a stream pointer, but not a hash pointer.
                die "Refusing to overwrite non-hashpointer stream pointer."
            else
                # The file is a normal file. Either it's the same, in which case do nothing, or it's different, in which case overwrite it.
                outFileHash="$(sha512sum < "$outFile" | awk '{print $1;}')"
                if [[ "$hashFull" == "$outFileHash" ]]; then
                    finish; exit 0
                else
                    mv "$streamId.tmp" "$outFileHash"
                    finish; exit 0
                fi
            fi
        fi
    fi
    # Upload a pack of the LocalStore items if there are enough, and update the pointers accordingly.
    if ! [[ -e "$crystalWorkdir/.LocalStoreCache/" ]]; then
        localstorecache_init "$crystalWorkdir/.LocalStoreCache/" 5000000000
    fi
    if ! [[ -e "$dbDir"/LocalStore ]]; then
        mkdir -p "$dbDir"/LocalStore
    fi
    localStoreSize="$(du -sb "$dbDir"/LocalStore | awk '{print $1;}')"
    if [[ "$localStoreSize" -gt 100000000 ]]; then
        if [[ "$localStoreSize" -gt 300000000 ]] && [[ -e "$dbDir"/.LocalStore.lock ]]; then
            die "LocalStore is larger than expected, and lock file is present. Has a previous invocation of sreg_flush_localstore crashed? If so, manually remove $dbDir/.LocalStore.lock and re-run sreg_flush_localstore... (It's possible that sreg_flush_localstore is still running, though.)"
        fi
        sreg_flush_localstore --sreg-dir "$sregDir" > /dev/null
    fi
    hashA="${hashFull:0:1}"
    hashB="${hashFull:1:1}"
    hashC="${hashFull:2:1}"
    hashDir="$dbDir/$hashA/$hashB/$hashC"
    mkdir -p "$hashDir"
    dbFilePath="$hashDir/$hashFull"
    tmpFilePath="$streamId.tmp.stored"
    streamSize="$(du -sb "$streamId.tmp" | awk '{print $1;}')"
    if [[ "$streamSize" -gt 10000000 ]]; then
        useLocalStore="false"
    else
        useLocalStore="true"
        localStoreDir="$dbDir/LocalStore/$hashA/$hashB/$hashC"
        mkdir -p "$localStoreDir"
        localStoreFilePath="$localStoreDir/$hashFull"
    fi
    sanityCheckPassed=""
    if [[ -f "$dbFilePath" ]]; then
        sanityCheckPassed="0"
        knownChecksum="$hashFull"
        if sregi_available_by_hash --sreg-dir "$sregDir" "$knownChecksum" &> /dev/null; then
            # Item already has been stored and passes a basic sanity check, so check that the existing pointer can be restored
            recoveredHash="$(sreg_read_stream --sreg-dir "$sregDir" --disallow-hash-pointer < "$dbFilePath" | sha512sum | awk '{print $1;}')"
            if [[ "$recoveredHash" != "$hashFull" ]]; then
                # This is a fatal error because this condition could go undetected a long time (since the pointer passed the basic sanity check), and should perhaps have human attention.
                die "Could not read existing item."
                # if [[ "$1" == "--verbose" ]]; then
                #     warn "Could not read existing item."
                # fi
                # fsckDir="$sregDir"/Failed\ Fsck/
                # mkdir -p "$fsckDir"
                # mv "$tmpFilePath" "$fsckDir"
            fi
            sanityCheckPassed="1"
        else
            # Item failed a basic sanity check, so it can pretty safely be removed and recreated, because it would presumably be found failed by that same basic sanity check in the course of general maintenance.
            rm "$dbFilePath"
        fi
    fi
    if [[ -f "$dbFilePath" ]] && [[ "$sanityCheckPassed" != "1" ]]; then
        die "Database entry did not pass sanity check, but still exists! This should never happen."
    fi
    if [[ ! -f "$dbFilePath" ]]; then
        # Item not available in cache, so add it (c39... is the LocalStore pointer type signature; a5e... is the remote type signature)
        pointerTypeSignature="c39f8657-384b-438b-a5a2-eece17147589"
        if [[ "$useLocalStore" != "true" ]]; then
            if [[ "$1" == "--verbose" ]]; then
                crystallize --passphrase "$(sregi_get_passphrase "$sregDir")" --leave-pointer "$streamId.tmp" | 1&>2
            else
                crystallize --passphrase "$(sregi_get_passphrase "$sregDir")" --leave-pointer "$streamId.tmp" &> /dev/null
            fi
            pointerTypeSignature="a5e2f296-3085-49c0-8f48-24ea436b7a8b"
        fi
        echo "$pointerTypeSignature" > "$tmpFilePath"
        echo "$hashFull" >> "$tmpFilePath"
        if [[ "$useLocalStore" != "true" ]]; then
            tar -c -P -S --format pax "$streamId.tmp.crystal" ".$streamId.tmp.crystal-data" > "$streamId.nonbundle.pointer.tar"
            [[ "$(xxd "$streamId.nonbundle.pointer.tar" | head -c 12)" == "00000000: 00" ]] && { mkdir -p "$(crystallize-getconf WorkDirectory)/.CorruptSregTarFileInfo/$streamId/"; rsync -a "$streamId.LocalStore.crystal" ".$streamId.LocalStore.crystal-data" "$streamId.nonbundle.pointer.tar" "$(crystallize-getconf WorkDirectory)/.CorruptSregTarFileInfo/$streamId/"; die "Pointer pax was corrupt!"; }
            xz -k -C sha256 -T 0 -9 -e --stdout - < "$streamId.nonbundle.pointer.tar" >> "$tmpFilePath"
        else
            xz -k -C sha256 -T 0 -9 -e --stdout "$streamId.tmp" > "$localStoreFilePath"
        fi
        trap finish EXIT
        sregi_verify_entry --sreg-dir "$sregDir" "$tmpFilePath" > /dev/null || die "Failed saving stream: stored stream could not be read!"
        trap - EXIT
        mv "$tmpFilePath" "$dbFilePath" || die "Could not move pointer into place!"
    fi
    # Output the finished hashpointer
    if [[ -n "$outFile" ]]; then
        printf '%s\n%s\n' "760fa662-89cf-4ebd-9664-150b7637ddd4" "$hashFull" > "$outFile"
    else
        printf '%s\n%s\n' "760fa662-89cf-4ebd-9664-150b7637ddd4" "$hashFull"
    fi
    finish
    if [[ -e "${streamId:?}.tmp" ]]; then
        rm "${streamId:?}.tmp"
    fi
    if [[ -e "${streamId:?}.tmp.crystal" ]]; then
        rm "${streamId:?}.tmp.crystal"
    fi
)
