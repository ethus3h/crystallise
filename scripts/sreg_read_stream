#!/bin/bash
source "$(which ember_bash_setup)" &> /dev/null

# Accepts a pointer on stdin, and outputs the corresponding data from the stream registry.

[ "$(whoami)" != "root" ] && exec sudo -- "$0" "$@"
function finish() {
    if [ -e "$streamId" ]; then
        rm -r "$streamId"
    fi
}
trap 'error-notify "A fatal error was reported on ${BASH_SOURCE} line ${LINENO}."; finish; exit 1' ERR

if [[ "--disallow-hash-pointer" == "$1" ]]; then
    disallowHashPointer="true"
    shift
fi
crystalWorkdir="$(crystallize-getconf 'WorkDirectory')"
streamId="biggify-stream-$(date +%Y-%m-%d-%H-%M-%S-%N)-$(xxd -pu <<< "$(date +%z)")"
dbDir="/Ember Library/Futuramerlin Projects/Data/Stream Registry/"
cd "$crystalWorkdir" || exit 1
# Set up cache directory
cacheDbDir="$crystalWorkdir/.StreamCache/"
if ! [ -e "$cacheDbDir" ]; then
    mkdir -p "$cacheDbDir"
    echo "5000000000" > "$cacheDbDir/.scache.limit"
fi
# Get stream
mkdir "$streamId"
(
    trap 'error-die "A fatal error was reported on ${BASH_SOURCE} line ${LINENO}."' ERR
    cd "$streamId" || exit 1
    sponge "$streamId.xz"
    numRetries=4
    numTotalRetries=4
    successfulRetrieval="0"
    trap 'warn "A nonfatal error was reported on ${BASH_SOURCE} line ${LINENO}."' ERR
    while [ "$numRetries" -gt 0 ] && [ "$successfulRetrieval" -eq 0 ]; do
        if [ "$numRetries" -lt "$numTotalRetries" ]; then
            sleep 30
            #echo "Beginning retry of reading stream. $numRetries retries remaining."
        fi
        numRetries=$(( numRetries - 1 ))
        # Get the hash of the stream
        hashFull="$(tail -c +38 "$streamId.xz" | head -c 129)"
        hashA="${hashFull:0:1}"
        hashB="${hashFull:1:1}"
        hashC="${hashFull:2:1}"
        # Set up this item's cache directory
        hashSubdir="$hashA/$hashB/$hashC"
        hashDir="$cacheDbDir/$hashSubdir"
        mkdir -p "$hashDir"
        dbLinkPath="$hashDir/$hashFull"
        if [ ! -h "$dbLinkPath" ] || [ ! -s "$(readlink "$dbLinkPath")" ]; then
            # Item is not in the cache, so add it
            if ! [ -f "$dbLinkPath" ]; then
                # Never seen this item before, so set the requestCount
                requestCount=1
            else
                requestCount="$(<"$dbLinkPath")"
                rm "$dbLinkPath"
            fi
            dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
            dbFilePath="$dbFileDir/$hashFull"
            mkdir -p "$dbFileDir"
            # Figure out what type of pointer it is
            pointerTypeSignature="$(head -c 36 "$streamId.xz")"
            if [[ "$pointerTypeSignature" == "a5e2f296-3085-49c0-8f48-24ea436b7a8b" ]]; then
                # Standard remote pointer
                tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                decrystallize-pointer ./*.crystal &> /dev/null
                cp scache-*.tmp "$streamId.out"
            elif [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
                # LocalStore pointer
                unxz --stdout - < "$dbDir/LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            elif [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]] || [[ "$pointerTypeSignature" == "2fae2004-94bb-4aa8-a01a-fc44298efc2c" ]]; then
                # Remote pack pointer
                if [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]]; then
                    # Pack pointer data is in the pointer
                    tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                else
                    # Pack pointer name is in the pointer, so get the pack pointer data from the Packs directory
                    packName="$(tail -c +167 "$streamId.xz")"
                    unxz --stdout - < "$dbDir/Packs/$packName" | tar -xf -
                fi
                if ! [ -e "$crystalWorkdir/.LocalStoreCache/" ]; then
                  localstorecache_init "$crystalWorkdir/.LocalStoreCache/" 5000000000
                fi
                crystalFilePattern=".*.crystal-data"
                crystalFilePatternMatches=( $crystalFilePattern )
                localStoreCrystalName="${crystalFilePatternMatches[0]}"
                localStoreCrystalIdentifier="$(<"$localStoreCrystalName"/identifier)"
                localstoreLocation="$(localstorecache_request "$crystalWorkdir/.LocalStoreCache/" "$localStoreCrystalIdentifier")"
                unxz --stdout - < "$localstoreLocation/scache-"*".LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            elif [[ "$pointerTypeSignature" == "760fa662-89cf-4ebd-9664-150b7637ddd4" ]]; then
                # Hash pointer
                if [[ "true" == "$disallowHashPointer" ]]; then
                    error-die "The provided pointer is a hash pointer!"
                fi
                sreg_read_stream < "$dbDir/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            else
                error-die "Unknown pointer type signature! Either the file is corrupted, or this is a pointer version this version of sreg_read_stream is not familiar with, or this is not a pointer. Aborting."
            fi
            mv "$streamId.out" "$dbFilePath"
            if [ -h "$dbLinkPath" ]; then
                rm "$dbLinkPath"
            fi
            ln -s "$dbFilePath" "$dbLinkPath"
        else
            # Item is in the cache.
            dbFilePath="$(readlink -e "$dbLinkPath")"
            dbFileOldPath="$dbFilePath"
            dbFileDir="$(dirname "$dbFilePath")"
            # First, make sure the link is good and fix it up if it's not.
            if ! [ -e "$dbFilePath" ]; then
                rm "$dbLinkPath"
                find "$cacheDbDir/ByCount" -maxdepth 2 -type f -name "$hashFull" -exec ln -s {} "$dbLinkPath" \;
            fi
            # Get the requestCount. There are three path components after it. I suspect there's a better way to do this.
            oldCount="$(basename "$(dirname "$(dirname "$(dirname "$dbFileDir")")")")"
            requestCount=$(( oldCount + 1 ))
            # Increment the item's requestCount.
            # First, get the names of where the file should go.
            dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
            dbFilePath="$dbFileDir/$hashFull"
            mkdir -p "$dbFileDir"
            mv "$dbFileOldPath" "$dbFilePath"
            rm "$dbLinkPath"
            ln -s "$dbFilePath" "$dbLinkPath"
        fi
        retrievedHash="$(sha512sum < "$dbLinkPath" | awk '{print $1;}')"
        if [[ "$retrievedHash" != "$hashFull" ]]; then
            mkdir -p "$cacheDbDir/Failed Checksum"
            mv "$dbFilePath" "$cacheDbDir/Failed Checksum/$(basename "$dbFilePath")"
            warn "Checksum mismatch when retrieving the requested stream!"
        else
            successfulRetrieval="1"
        fi
    done
    trap 'error-die "A fatal error was reported on ${BASH_SOURCE} line ${LINENO}."' ERR
    if [[ "$successfulRetrieval" != "1" ]]; then
        error-die "Failed retrieving stream, and no retries left!"
    fi
    cat "$dbLinkPath"
    # Clean up empty directories
    find "$cacheDbDir" -type d -empty -delete
    # Remove the least-used items from the cache until it fits within the alloted disk space
    diskUsageLimit="$(<"$cacheDbDir"/.scache.limit)"
    while [ "$(du -sb "$cacheDbDir" | awk '{print $1;}')" -gt "$diskUsageLimit" ]; do
        rm -f "$cacheDbDir"/Failed\ Checksum/*
        # Remove the least-used item from the cache
        leastUsedItemDirectory="$(find "$cacheDbDir/ByCount" -maxdepth 1 -type d | sort -n | head -n 2 | tail -n 1)"
        largestLeastUsedItem="$(find "$leastUsedItemDirectory" -maxdepth 4 -type f -printf "%s\t%p\n" | sort -n | tail -1 | awk '{print $2;}')"
        leastUsedItemCount="$(basename "$leastUsedItemDirectory")"
        hashFull="$(basename "$largestLeastUsedItem")"
        rm -f "$largestLeastUsedItem"
        hashA="${hashFull:0:1}"
        hashB="${hashFull:1:1}"
        hashC="${hashFull:2:1}"
        hashSubdir="$hashA/$hashB/$hashC"
        hashDir="$cacheDbDir/$hashSubdir"
        dbLinkPath="$hashDir/$hashFull"
        rm -f "$dbLinkPath"
        echo "$leastUsedItemCount" > "$dbLinkPath"
    done
)
finish
trap finish EXIT
