diff --git a/HISTORY.rst b/HISTORY.rst
index 04f21f6..da91d1e 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -68,6 +68,10 @@ Release History
 - ``s3_is_overloaded()`` now returns ``True`` if the call is unsuccessful.
 - Fixed bug in upload where a derive task wasn't being queued when a directory is uploaded.
 
+1.0.4.dev1.b (2016-05-20a21)
+++++++++++++++++++
+Merge upstream changes
+
 1.0.3 (2016-05-16)
 ++++++++++++++++++
 
@@ -102,6 +106,36 @@ Release History
 - Fixed bug in upload where filenames with ``;`` characters were being truncated.
 - Fixed bug in ``internetarchive.catalog`` where TypeError was being raised in Python 3 due to mixing bytes with strings.
 
+1.0.2.3 (2016-04-11a12)
+++++++++++++++++++
+
+**Miscellaneous**
+
+-Unbreaking it.
+
+
+1.0.2.2 (2016-04-11a12)
+++++++++++++++++++
+
+**Features and Improvements**
+
+- Radical retry
+
+**Miscellaneous**
+
+-Pull in changes from upstream
+
+1.0.2.1 (2016-03-10)
+++++++++++++++++++
+
+**Features and Improvements**
+
+- Retry on HTTP response codes 500, 501, 502, 503, 504, 400, and 408.
+
+**Miscellaneous**
+
+- Fork of jjjake/internetarchive.
+
 1.0.2 (2016-03-07)
 ++++++++++++++++++
 
diff --git a/internetarchive/item.py b/internetarchive/item.py
index a993087..562ccae 100644
--- a/internetarchive/item.py
+++ b/internetarchive/item.py
@@ -587,54 +587,61 @@ def _build_request():
         if debug:
             return _build_request()
         else:
-            try:
-                error_msg = ('s3 is overloaded, sleeping for '
-                             '{0} seconds and retrying. '
-                             '{1} retries left.'.format(retries_sleep, retries))
-                while True:
-                    if retries > 0:
-                        if self.session.s3_is_overloaded(access_key):
-                            sleep(retries_sleep)
-                            log.info(error_msg)
-                            if verbose:
-                                print(' warning: {0}'.format(error_msg), file=sys.stderr)
-                            retries -= 1
-                            continue
-                    request = _build_request()
-                    prepared_request = request.prepare()
-                    response = self.session.send(prepared_request,
-                                                 stream=True,
-                                                 **request_kwargs)
-                    if (response.status_code == 503) and (retries > 0):
-                        log.info(error_msg)
+            attempts = 0
+            while attempts < 10:
+                try:
+                    try:
+                        error_msg = ('s3 is overloaded, sleeping for '
+                                     '{0} seconds and retrying. '
+                                     '{1} retries left.'.format(retries_sleep, retries))
+                        while True:
+                            if retries > 0:
+                                if self.session.s3_is_overloaded(access_key):
+                                    sleep(retries_sleep)
+                                    log.info(error_msg)
+                                    if verbose:
+                                        print(' warning: {0}'.format(error_msg), file=sys.stderr)
+                                    retries -= 1
+                                    continue
+                            request = _build_request()
+                            prepared_request = request.prepare()
+                            response = self.session.send(prepared_request,
+                                                         stream=True,
+                                                         **request_kwargs)
+                            status_to_retry = [500, 501, 502, 503, 504, 400, 408]
+                            if (response.status_code in status_to_retry) and (retries > 0):
+                                log.info(error_msg)
+                                if verbose:
+                                    print(' warning: {0}'.format(error_msg), file=sys.stderr)
+                                sleep(retries_sleep)
+                                retries -= 1
+                                continue
+                            else:
+                                if response.status_code in status_to_retry:
+                                    log.info('maximum retries exceeded, upload failed.')
+                                break
+                        response.raise_for_status()
+                        log.info('uploaded {f} to {u}'.format(f=key, u=url))
+                        if delete and response.status_code == 200:
+                            log.info(
+                                '{f} successfully uploaded to '
+                                'https://archive.org/download/{i}/{f} and verified, deleting '
+                                'local copy'.format(i=self.identifier,
+                                                    f=key))
+                            os.remove(body.name)
+                        return response
+                    except HTTPError as exc:
+                        msg = get_s3_xml_text(exc.response.content)
+                        error_msg = (' error uploading {0} to {1}, '
+                                     '{2}'.format(key, self.identifier, msg))
+                        log.error(error_msg)
                         if verbose:
-                            print(' warning: {0}'.format(error_msg), file=sys.stderr)
-                        sleep(retries_sleep)
-                        retries -= 1
-                        continue
-                    else:
-                        if response.status_code == 503:
-                            log.info('maximum retries exceeded, upload failed.')
-                        break
-                response.raise_for_status()
-                log.info('uploaded {f} to {u}'.format(f=key, u=url))
-                if delete and response.status_code == 200:
-                    log.info(
-                        '{f} successfully uploaded to '
-                        'https://archive.org/download/{i}/{f} and verified, deleting '
-                        'local copy'.format(i=self.identifier,
-                                            f=key))
-                    os.remove(body.name)
-                return response
-            except HTTPError as exc:
-                msg = get_s3_xml_text(exc.response.content)
-                error_msg = (' error uploading {0} to {1}, '
-                             '{2}'.format(key, self.identifier, msg))
-                log.error(error_msg)
-                if verbose:
-                    print(' error uploading {0}: {1}'.format(key, msg), file=sys.stderr)
-                # Raise HTTPError with error message.
-                raise type(exc)(error_msg, response=exc.response, request=exc.request)
+                            print(' error uploading {0}: {1}'.format(key, msg), file=sys.stderr)
+                        # Raise HTTPError with error message.
+                        raise type(exc)(error_msg, response=exc.response, request=exc.request)
+                except:
+                    attempts += 1
+                    print("error; retrying")
 
     def upload(self, files,
                metadata=None,
diff --git a/setup.py b/setup.py
index de27e2a..e35d163 100644
--- a/setup.py
+++ b/setup.py
@@ -19,9 +19,9 @@
 setup(
     name='internetarchive',
     version=version,
-    url='https://github.com/jjjake/internetarchive',
+    url='https://github.com/ethus3h/internetarchive',
     license='AGPL 3',
-    author='Jacob M. Johnson',
+    author='Jacob M. Johnson; ethus3h',
     author_email='jake@archive.org',
     description='A python interface to archive.org.',
     long_description=readme,
