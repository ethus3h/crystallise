#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null

((EUID)) && exec sudo -- "$0" "$@"
#set -x

function finish() {
    if [[ -e "${streamId:?}" ]]; then
        rm -r "${streamId:?}"
    fi
}
trap 'error-notify "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; finish; exit 1' ERR
trap finish EXIT

if [[ "$1" == "--checksum" ]]; then
    shift
    knownChecksum="$1"
    shift
fi
if [[ "--disallow-hash-pointer" == "$1" ]]; then
    disallowHashPointer="true"
    shift
fi
skipCache="false"
if [[ "--skip-cache" == "$1" ]]; then
    skipCache="true"
    shift
fi
crystalWorkdir="$(crystallize-getconf 'WorkDirectory')"
cd "$crystalWorkdir" || exit 1
streamId="sreg_read_stream-$(date +%Y-%m-%d-%H-%M-%S-%N)-$(xxd -pu <<< "$(date +%z)")"
dbDir="${EmberLibrary:?}/Futuramerlin Projects/Data/Stream Registry/"
# Set up cache directory
cacheDbDir="$crystalWorkdir/.StreamCache/"
if ! [[ -e "$cacheDbDir" ]]; then
    mkdir -p "$cacheDbDir"
    echo "5000000000" > "$cacheDbDir/.scache.limit"
fi
# Get stream
mkdir "$streamId"
(
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    cd "$streamId" || exit 1
    sponge "$streamId.xz"
    numRetries=40
    numTotalRetries="$numRetries"
    successfulRetrieval="0"
    # Get the hash of the stream
    hashFull="$(tail -c +38 "$streamId.xz" | head -c 129)"
    if [[ -n "$knownChecksum" ]]; then
        [[ "$knownChecksum" == "$hashFull" ]] || die "The checksum provided by the pointer does not match the provided checksum."
    fi
    hashA="${hashFull:0:1}"
    hashB="${hashFull:1:1}"
    hashC="${hashFull:2:1}"
    # Set up this item's cache directory
    hashSubdir="$hashA/$hashB/$hashC"
    hashDir="$cacheDbDir/$hashSubdir"
    mkdir -p "$hashDir"
    dbLinkPath="$hashDir/$hashFull"
    trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    while [[ "$numRetries" -gt 0 ]] && [[ "$successfulRetrieval" -eq 0 ]]; do
        trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
        if [[ "$numRetries" -lt "$numTotalRetries" ]]; then
            sleep 30
            echo "Beginning retry of reading stream. $numRetries retries remaining."
        fi
        numRetries=$(( numRetries - 1 ))
        if [[ ! -h "$dbLinkPath" ]] || [[ ! -f "$(readlink "$dbLinkPath")" ]] || [[ "$skipCache" == "true" ]]; then
            if [[ "$skipCache" == "true" ]]; then
                if [[ -h "$dbLinkPath" ]] && [[ -f "$(readlink "$dbLinkPath")" ]]; then
                    # Get the requestCount. There are three path components after it. I suspect there's a better way to do this.
                    dbFilePath="$(readlink -e "$dbLinkPath")"
                    requestCount="$(basename "$(dirname "$(dirname "$(dirname "$(dirname "$dbFilePath")")")")")"
                    if [[ -z "$requestCount" ]]; then
                        requestCount="0"
                    fi
                fi
            else
                # Item is not in the cache, so add it
                if ! [[ -f "$dbLinkPath" ]]; then
                    # Never seen this item before, so set the requestCount
                    requestCount=1
                else
                    requestCount="$(<"$dbLinkPath")"
                    rm "$dbLinkPath"
                fi
            fi
            dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
            dbFilePath="$dbFileDir/$hashFull"
            mkdir -p "$dbFileDir"
            # Figure out what type of pointer it is
            pointerTypeSignature="$(head -c 36 "$streamId.xz")"
            if [[ "$pointerTypeSignature" == "a5e2f296-3085-49c0-8f48-24ea436b7a8b" ]]; then
                # Standard remote pointer
                tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                decrystallize-pointer ./*.crystal --here &> /dev/null
                cp scache-*.tmp "$streamId.out"
            elif [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
                # LocalStore pointer
                trap 'warn "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} while attempting to read a LocalStore pointer. Giving up now: retrying would likely not help in this situation."; numRetries=0' ERR
                unxz --stdout - < "$dbDir/LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            elif [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]] || [[ "$pointerTypeSignature" == "2fae2004-94bb-4aa8-a01a-fc44298efc2c" ]]; then
                # Remote pack pointer
                if [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]]; then
                    # Pack pointer data is in the pointer
                    tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                else
                    # Pack pointer name is in the pointer, so get the pack pointer data from the Packs directory
                    packName="$(tail -c +167 "$streamId.xz")"
                    unxz --stdout - < "$dbDir/Packs/$packName" | tar -xf -
                fi
                trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
                if ! [[ -e "$crystalWorkdir/.LocalStoreCache/" ]]; then
                    localstorecache_init "$crystalWorkdir/.LocalStoreCache/" 5000000000
                fi
                crystalFilePattern=".*.crystal-data"
                crystalFilePatternMatches=( $crystalFilePattern )
                localStoreCrystalName="${crystalFilePatternMatches[0]}"
                if ! [[ -e "$localStoreCrystalName" ]]; then
                    error-notify "Crystal info could not be found in the pointer, so giving up immediately (retrying probably wouldn't help this)."
                fi
                localStoreCrystalIdentifier="$(<"$localStoreCrystalName"/identifier)"
                localstoreLocation="$(localstorecache_request "$crystalWorkdir/.LocalStoreCache/" "$localStoreCrystalIdentifier")"
                unxz --stdout - < "$localstoreLocation/scache-"*".LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            elif [[ "$pointerTypeSignature" == "760fa662-89cf-4ebd-9664-150b7637ddd4" ]]; then
                # Hash pointer
                if [[ "true" == "$disallowHashPointer" ]]; then
                    die "The provided pointer is a hash pointer!"
                fi
                if ! [[ -e "$dbDir/$hashA/$hashB/$hashC/$hashFull" ]]; then
                    die "The provided pointer is a hash pointer, but the corresponding hash is not registered in the database! ($dbDir/$hashA/$hashB/$hashC/$hashFull does not exist.)"
                fi
                sreg_read_stream < "$dbDir/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            else
                # The file isn't a stream pointer, so just return it and exit
                cat "$streamId.xz"
                exit 0
            fi
            xz --stdout -0 "$streamId.out" > "$dbFilePath"
            rm "$streamId.out"
            if [[ -e "$dbLinkPath" ]]; then
                rm "$dbLinkPath"
            fi
            ln -s "$dbFilePath" "$dbLinkPath"
        fi
        dbFilePath="$(readlink -e "$dbLinkPath")"
        # First, make sure the link is good and fix it up if it's not.
        if ! [[ -f "$dbFilePath" ]]; then
            find "$cacheDbDir/ByCount" -mindepth 5 -maxdepth 5 -type f -name "$hashFull" -exec ln -sf {} "$dbLinkPath" \;
            dbFilePath="$(readlink -e "$dbLinkPath")"
        fi
        dbFileOldPath="$dbFilePath"
        dbFileDir="$(dirname "$dbFilePath")"
        # Get the requestCount. There are three path components after it. I suspect there's a better way to do this.
        oldCount="$(basename "$(dirname "$(dirname "$(dirname "$dbFileDir")")")")"
        if ! [[ "$oldCount" =~ ^-?[0-9]+$ ]]; then
            rm "$dbLinkPath"
            continue
        fi
        # Increment the item's requestCount.
        requestCount=$(( oldCount + 1 ))
        # First, get the names of where the file should go.
        dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
        dbFilePath="$dbFileDir/$hashFull"
        mkdir -p "$dbFileDir"
        mv "$dbFileOldPath" "$dbFilePath"
        if [[ -e "$dbLinkPath" ]]; then
            rm "$dbLinkPath"
        fi
        ln -s "$dbFilePath" "$dbLinkPath"
        # Done cache cleanup
        decompressedCacheEntry="$streamId.dat"
        unxz --stdout - < "$dbLinkPath" > "$decompressedCacheEntry"
        retrievedHash="$(sha512sum < "$decompressedCacheEntry" | awk '{print $1;}')"
        if [[ "$retrievedHash" != "$hashFull" ]]; then
            rm "$dbFilePath" "$dbLinkPath"
            echo "$oldCount" > "$dbLinkPath"
            # mkdir -p "$cacheDbDir/Failed Checksum"
            # mv "$dbFilePath" "$cacheDbDir/Failed Checksum/$(basename "$dbFilePath")"
            # warn "Checksum mismatch when retrieving the requested stream!"
            error-notify "Checksum mismatch when retrieving the requested stream!"
            # if [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
            #     mkdir -p "$dbDir/LocalStore/Failed\ Fsck/"
            #     mv "$dbDir/LocalStore/$hashA/$hashB/$hashC/$hashFull" "$dbDir/LocalStore/Failed\ Fsck/"
            #     die "LocalStore entry was corrupted!"
            # fi
        else
            successfulRetrieval="1"
        fi
    done
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    if [[ "$successfulRetrieval" != "1" ]]; then
        die "Failed retrieving stream, and no retries left!"
    fi
    cat "$decompressedCacheEntry"
    # Cache cleanup is expensive, so only do it occasionally
    if [[ "$RANDOM" -lt 250 ]]; then
        scache_gc "$cacheDbDir"
    fi
)
finish
