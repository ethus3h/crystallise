#!/bin/bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null

((EUID)) && exec sudo -- "$0" "$@"
#set -x

function finish() {
    if [[ -e "$streamId" ]]; then
        rm -r "$streamId"
    fi
}
trap 'error-notify "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."; finish; exit 1' ERR

if [[ "$1" == "--checksum" ]]; then
    shift
    knownChecksum="$1"
    shift
fi
if [[ "--disallow-hash-pointer" == "$1" ]]; then
    disallowHashPointer="true"
    shift
fi
crystalWorkdir="$(crystallize-getconf 'WorkDirectory')"
streamId="biggify-stream-$(date +%Y-%m-%d-%H-%M-%S-%N)-$(xxd -pu <<< "$(date +%z)")"
dbDir="${EmberLibrary:?}/Futuramerlin Projects/Data/Stream Registry/"
cd "$crystalWorkdir" || exit 1
# Set up cache directory
cacheDbDir="$crystalWorkdir/.StreamCache/"
if ! [[ -e "$cacheDbDir" ]]; then
    mkdir -p "$cacheDbDir"
    echo "5000000000" > "$cacheDbDir/.scache.limit"
fi
# Get stream
mkdir "$streamId"
(
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    cd "$streamId" || exit 1
    sponge "$streamId.xz"
    numRetries=5
    numTotalRetries=5
    successfulRetrieval="0"
    # Get the hash of the stream
    hashFull="$(tail -c +38 "$streamId.xz" | head -c 129)"
    if [[ -n "$knownChecksum" ]]; then
        [[ "$knownChecksum" == "$hashFull" ]] || die "The checksum provided by the pointer does not match the provided checksum."
    fi
    hashA="${hashFull:0:1}"
    hashB="${hashFull:1:1}"
    hashC="${hashFull:2:1}"
    # Set up this item's cache directory
    hashSubdir="$hashA/$hashB/$hashC"
    hashDir="$cacheDbDir/$hashSubdir"
    mkdir -p "$hashDir"
    dbLinkPath="$hashDir/$hashFull"
    trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    while [[ "$numRetries" -gt 0 ]] && [[ "$successfulRetrieval" -eq 0 ]]; do
        if [[ "$numRetries" -lt "$numTotalRetries" ]]; then
            sleep 30
            echo "Beginning retry of reading stream. $numRetries retries remaining."
        fi
        numRetries=$(( numRetries - 1 ))
        if [[ ! -h "$dbLinkPath" ]] || [[ ! -f "$(readlink "$dbLinkPath")" ]]; then
            # Item is not in the cache, so add it
            if ! [[ -f "$dbLinkPath" ]]; then
                # Never seen this item before, so set the requestCount
                requestCount=1
            else
                requestCount="$(<"$dbLinkPath")"
                rm "$dbLinkPath"
            fi
            dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
            dbFilePath="$dbFileDir/$hashFull"
            mkdir -p "$dbFileDir"
            # Figure out what type of pointer it is
            pointerTypeSignature="$(head -c 36 "$streamId.xz")"
            if [[ "$pointerTypeSignature" == "a5e2f296-3085-49c0-8f48-24ea436b7a8b" ]]; then
                # Standard remote pointer
                tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                decrystallize-pointer ./*.crystal --here &> /dev/null
                cp scache-*.tmp "$streamId.out"
            elif [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
                # LocalStore pointer
                trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} while attempting to read a LocalStore pointer. Giving up now: retrying would likely not help in this situation."; numRetries=0' ERR
                unxz --stdout - < "$dbDir/LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            elif [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]] || [[ "$pointerTypeSignature" == "2fae2004-94bb-4aa8-a01a-fc44298efc2c" ]]; then
                # Remote pack pointer
                if [[ "$pointerTypeSignature" == "209fcfdf-d1ad-4345-8ef7-1fdc2d583d49" ]]; then
                    # Pack pointer data is in the pointer
                    tail -c +167 "$streamId.xz" | unxz --stdout - | tar -xf -
                else
                    # Pack pointer name is in the pointer, so get the pack pointer data from the Packs directory
                    packName="$(tail -c +167 "$streamId.xz")"
                    unxz --stdout - < "$dbDir/Packs/$packName" | tar -xf -
                fi
                if ! [[ -e "$crystalWorkdir/.LocalStoreCache/" ]]; then
                  localstorecache_init "$crystalWorkdir/.LocalStoreCache/" 5000000000
                fi
                trap 'warn "A nonfatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
                crystalFilePattern=".*.crystal-data"
                crystalFilePatternMatches=( $crystalFilePattern )
                localStoreCrystalName="${crystalFilePatternMatches[0]}"
                if ! [[ -e "$localStoreCrystalName" ]]; then
                    die "Crystal info could not be found in the pointer, so giving up immediately (retrying probably wouldn't help this)."
                fi
                localStoreCrystalIdentifier="$(<"$localStoreCrystalName"/identifier)"
                localstoreLocation="$(localstorecache_request "$crystalWorkdir/.LocalStoreCache/" "$localStoreCrystalIdentifier")"
                unxz --stdout - < "$localstoreLocation/scache-"*".LocalStore/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
                rm -r "$localstoreLocation"
            elif [[ "$pointerTypeSignature" == "760fa662-89cf-4ebd-9664-150b7637ddd4" ]]; then
                # Hash pointer
                if [[ "true" == "$disallowHashPointer" ]]; then
                    die "The provided pointer is a hash pointer!"
                fi
                if ! [[ -e "$dbDir/$hashA/$hashB/$hashC/$hashFull" ]]; then
                    die "The provided pointer is a hash pointer, but the corresponding hash is not registered in the database! ($dbDir/$hashA/$hashB/$hashC/$hashFull does not exist.)"
                fi
                sreg_read_stream < "$dbDir/$hashA/$hashB/$hashC/$hashFull" > "$streamId.out"
            else
                die "Unknown pointer type signature! Either the file is corrupted, or this is a pointer version this version of sreg_read_stream is not familiar with, or this is not a pointer. Aborting."
            fi
            mv "$streamId.out" "$dbFilePath"
            if [[ -h "$dbLinkPath" ]]; then
                rm "$dbLinkPath"
            fi
            ln -s "$dbFilePath" "$dbLinkPath"
        fi
        dbFilePath="$(readlink -e "$dbLinkPath")"
        # First, make sure the link is good and fix it up if it's not.
        if ! [[ -f "$dbFilePath" ]]; then
            find "$cacheDbDir/ByCount" -maxdepth 2 -type f -name "$hashFull" -exec ln -sf {} "$dbLinkPath" \;
            dbFilePath="$(readlink -e "$dbLinkPath")"
        fi
        dbFileOldPath="$dbFilePath"
        dbFileDir="$(dirname "$dbFilePath")"
        # Get the requestCount. There are three path components after it. I suspect there's a better way to do this.
        oldCount="$(basename "$(dirname "$(dirname "$(dirname "$dbFileDir")")")")"
        if [[ "$oldCount" == "." ]]; then
            continue
        fi
        # Increment the item's requestCount.
        requestCount=$(( oldCount + 1 ))
        # First, get the names of where the file should go.
        dbFileDir="$cacheDbDir/ByCount/$requestCount/$hashSubdir"
        dbFilePath="$dbFileDir/$hashFull"
        mkdir -p "$dbFileDir"
        mv "$dbFileOldPath" "$dbFilePath"
        rm "$dbLinkPath"
        ln -s "$dbFilePath" "$dbLinkPath"
        # Done cache cleanup
        retrievedHash="$(sha512sum < "$dbLinkPath" | awk '{print $1;}')"
        if [[ "$retrievedHash" != "$hashFull" ]]; then
            mkdir -p "$cacheDbDir/Failed Checksum"
            mv "$dbFilePath" "$cacheDbDir/Failed Checksum/$(basename "$dbFilePath")"
            warn "Checksum mismatch when retrieving the requested stream!"
            if [[ "$pointerTypeSignature" == "c39f8657-384b-438b-a5a2-eece17147589" ]]; then
                mkdir -p "$dbDir/LocalStore/Failed\ Fsck/"
                mv "$dbDir/LocalStore/$hashA/$hashB/$hashC/$hashFull" "$dbDir/LocalStore/Failed\ Fsck/"
                die "LocalStore entry was corrupted!"
            fi
        else
            successfulRetrieval="1"
        fi
    done
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    if [[ "$successfulRetrieval" != "1" ]]; then
        die "Failed retrieving stream, and no retries left!"
    fi
    cat "$dbLinkPath"
    # Cache cleanup is expensive, so only do it occasionally
    if [[ "$RANDOM" -lt 250 ]]; then
        scache_gc "$cacheDbDir"
    fi
)
finish
trap finish EXIT
